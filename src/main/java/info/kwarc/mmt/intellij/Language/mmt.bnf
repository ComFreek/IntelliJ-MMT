{
    parserClass="info.kwarc.mmt.intellij.Language.MMTParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="MMT"
    psiImplClassSuffix="_impl"
    psiPackage="info.kwarc.mmt.intellij.Language.psi"
    psiImplPackage="info.kwarc.mmt.intellij.Language.psi.imps"

    elementTypeHolderClass="info.kwarc.mmt.intellij.Language.psi.MMTParserTypes"
    elementTypeClass="info.kwarc.mmt.intellij.Language.psi.MMTElementType"
    tokenTypeClass="info.kwarc.mmt.intellij.Language.psi.MMTTokenType"
}

file ::= mod*

mod ::= namespace | import | modcmd | theory | view

modcmd ::= COMMENT_KEY COMMENT* MD

namespace ::= NAMESPACE_KEY URI MD
import ::= IMPORT_KEY PSEUDONAME URI MD

theory ::=  theoryheader ((ABBREV_KEY term) | (EQ_KEY module_body)) MD
theoryheader ::= THEORY_KEY NAME (TYPE_KEY URI)? (PARAM_KEY tmlist OD)?
module_body ::= declaration*
term ::= TMSYM+
tmlist ::= (term COMMA_KEY)* term

declaration ::= rule | include | constant | decl_comment | theory | structure | nestedview | deriveddecl

rule ::= RULE_KEY URI tmlist? DD
include ::= INCLUDE_KEY URI tmlist DD
decl_comment ::= COMMENT_KEY COMMENT* DD
constant ::= NAME (component OD)* component? DD
deriveddecl ::= DERIVED+ ((DERIVEDSHORT DD) | (DERIVEDBODY module_body MD) )

component::= obj_comment | type_comp | eq_comp | not_comp | role_comp | meta_comp | alias_comp

obj_comment ::= COMMENT_KEY COMMENT*
type_comp ::= TYPE_KEY term
eq_comp ::= EQ_KEY term
not_comp ::= NOT_KEY NOTATION+
role_comp ::= ROLE_KEY PSEUDONAME
meta_comp ::= META_KEY term
alias_comp ::= ALIAS_KEY NAME

TODOs ::= (
    VIEW_KEY |
    IMPLICIT_KEY |
    STRUCTURE_KEY |
    COMMA_KEY |
    ARROW_KEY |
    WHITESPACE |
    INVALID
    )
/*
file ::= mod*

mod ::= (NAMESPACE_KEY URI MD) | (IMPORT_KEY NAME URI MD) | (COMMENT MD) | (theory MD) | (view MD)

// temp ::= DD

//
theory ::= THEORY_KEY NAME (TYPE_KEY URI)? (PARAM_KEY TERM* OD)? ((ABBREV_KEY TERM) | (EQ_KEY (declaration | nestedtheory | nestedview)*))
// theory ::= THEORY_KEY NAME (TYPE_KEY URI)? (PARAM_KEY TERM* OD)? ((ABBREV_KEY TERM) | (EQ_KEY COMMENT*))
view ::= IMPLICIT_KEY? VIEW_KEY TOKEN TYPE_KEY TOKEN ARROW_KEY TOKEN ((ABBREV_KEY string) | (EQ_KEY (viewdecl DECLDELIM)+))

declaration ::= (DECL DD) | rule | include | constant | COMMENT_D | nestedview | structure

rule ::= RULE_KEY URI
include ::= INCLUDE_KEY
constant ::= TOKEN ((component OD)+ component)?
nestedtheory ::= theory MD
nestedview ::= view MD
structure ::= IMPLICIT_KEY? STRUCTURE_KEY NAME TYPE_KEY URI ((ABBREV_KEY string) | (EQ_KEY ((constant | includeassignment | structureassignment) DD)+)) MD

viewdecl ::= includeassignment | structureassignment | comment | assignment

includeassignment ::= INCLUDE_KEY NAME EQ_KEY string
structureassignment ::= STRUCTURE_KEY NAME EQ_KEY string
assignment ::= NAME EQ_KEY string

component ::= (type | def | notation | role | alias | COMMENT_O)

type ::= TYPE_KEY TERM
def ::= EQ_KEY TERM
notation ::= NOT_KEY TERM
role ::= ROLE_KEY TOKEN
alias ::= ALIAS_KEY TOKEN
*/