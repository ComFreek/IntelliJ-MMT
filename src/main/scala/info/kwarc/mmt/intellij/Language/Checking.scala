package info.kwarc.mmt.intellij.Language

import java.awt.BorderLayout
import java.awt.event.{ActionEvent, ActionListener}
import java.util

import com.intellij.lang.annotation.{AnnotationHolder, ExternalAnnotator, HighlightSeverity}
import com.intellij.openapi.editor.Editor
import com.intellij.openapi.project.Project
import com.intellij.openapi.util.TextRange
import com.intellij.openapi.wm.{ToolWindow, ToolWindowFactory}
import com.intellij.psi.{PsiElement, PsiFile}
import com.intellij.psi.impl.source.tree.TreeElement
import com.intellij.psi.util.PsiTreeUtil
import com.intellij.ui.treeStructure.{PatchedDefaultMutableTreeNode, Tree}
import info.kwarc.mmt.api
import info.kwarc.mmt.api.documents.Document
import info.kwarc.mmt.api.frontend.Controller
import info.kwarc.mmt.api.objects.WFJudgement
import info.kwarc.mmt.api.{DPath, Error, ErrorHandler, Invalid, InvalidElement, InvalidObject, InvalidUnit, MMTInterpretationProgress, MMTTaskProgress, MMTTaskProgressListener, Parsed, SourceError, StructuralElement, archives, metadata, utils}
import info.kwarc.mmt.api.parser.{ParsingStream, SourcePosition, SourceRef, SourceRegion}
import info.kwarc.mmt.api.symbols.{Declaration, FinalConstant}
import info.kwarc.mmt.api.utils.{File, FilePath, URI, stringToList}
import info.kwarc.mmt.intellij.Language.psi.{MMTElementType, MMTParserTypes}
import info.kwarc.mmt.intellij.MMT
import javax.swing.tree._
import javax.swing._
import javax.swing.event.TreeModelListener

object Conversions {
  implicit def convert(sr : SourceRegion, psi : PsiFile) : TextRange = {
    val start = sr.start.offset
    val length = sr.length
    val tr = TextRange.from(start,length)
    val int = psi.getTextRange.intersection(tr)
    if (int != null) int else psi.getTextRange
  }
}

import Conversions._

class ExtAnnotator extends ExternalAnnotator[Option[MMT],Option[MMT]] {
  override def apply(psifile: PsiFile, mmtO: Option[MMT], holder: AnnotationHolder): Unit = mmtO match {
    case Some(mmt) =>
      val uri = URI(psifile.getVirtualFile.toString)
      val file = utils.FileURI.unapply(uri).getOrElse(return)
      //val uri = utils.FileURI(file)
      val text = File.read(file)
      val nsMap = mmt.controller.getNamespaceMap
      val ps = mmt.controller.backend.resolvePhysical(file) orElse mmt.controller.backend.resolveAnyPhysicalAndLoad(file) match {
        case None =>
          ParsingStream.fromString(text, DPath(uri), file.getExtension.getOrElse(""), Some(nsMap))
        case Some((a, p)) =>
          ParsingStream.fromSourceFile(a, FilePath(p), Some(ParsingStream.stringToReader(text)), Some(nsMap))
      }
      ps.addListener(new Progresser(psifile,holder))
      mmt.errorViewer.clearFile(file)
      val error = new ErrorForwarder(psifile,file,mmt.controller,holder,mmt.errorViewer)
      val doc = mmt.controller.read(ps, true, true)(error) match {
        case d: Document => d
        case _ => //throw ImplementationError("document expected")
      }
      // add narrative structure of doc to outline tree
      // val tree = new SideKickParsedData(path.toJava.getName)
      // val root = tree.root
      // buildTreeDoc(root, doc)
      // tree
    case _ =>
  }

  override def collectInformation(file: PsiFile, editor: Editor, hasErrors: Boolean): Option[MMT] = {
    MMT.get(editor.getProject)
  }

  override def doAnnotate(collectedInfo: Option[MMT]): Option[MMT] = {
    // println("Here 2")
    collectedInfo
  }

}

class Progresser(file : PsiFile,holder : AnnotationHolder) extends MMTTaskProgressListener {
  override def apply(p: MMTTaskProgress): Unit = p match {
    case Parsed(c : FinalConstant) =>
      SourceRef.get(c) match {
        case Some(r) =>
          // holder.createAnnotation(HighlightSeverity.WARNING,r.region,"Checking...")
        case _ =>
      }
    case _ =>
  }
}


//TODO refactor
class ErrorForwarder(psifile : PsiFile, file: File, controller : Controller,holder : AnnotationHolder, ev : ErrorViewer) extends ErrorHandler {
  import info.kwarc.mmt.api._
  import archives.source
  import objects._
  import parser._
  import utils.MyList._

  override protected def addError(e: api.Error): Unit = e match {
    case s: SourceError =>
      /*
      //generated by parsers
      // We permit the case that errors are found in other files than the current one. So we compute the file path
      val nf = controller.backend.resolveLogical(s.ref.container) match {
        case Some((a, p)) => (a / source / p).toString
        case None => s.ref.container match {
          case utils.FileURI(f) => f.toString
          case u => u.toString
        }
      }
      */
      val region = convert(s.ref.region,psifile)
      holder.createErrorAnnotation(region,s.mainMessage)
      ev.addError(s.mainMessage,s.extraMessages,file,region)
    case e: Invalid =>
      //generated by checkers
      var mainMessage = e.shortMsg
      var extraMessages : List[String] = e.extraMessage.split("\n").toList
      val causeOpt: Option[metadata.HasMetaData] = e match {
        case e: InvalidObject => Some(e.obj)
        case e: InvalidElement => Some(e.elem)
        case e: InvalidUnit =>
          val steps = e.history.getSteps
          extraMessages :::= steps.map(_.present(o => controller.presenter.asString(o)))
          val declOpt = e.unit.component.map(p => controller.localLookup.get(p.parent))
          // WFJudgement must exist because we always start with it
          // find first WFJudgement whose region is within the failed checking unit
          declOpt.flatMap {decl =>
            SourceRef.get(decl).flatMap {bigRef =>
              steps.mapFind {s =>
                s.removeWrappers match {
                  case j: WFJudgement =>
                    SourceRef.get(j.wfo) flatMap {smallRef =>
                      if (bigRef contains smallRef) {
                        mainMessage += ": " + controller.presenter.asString(j.wfo)
                        Some(j.wfo)
                      } else
                        None
                    }
                  case _ =>
                    None
                }
              }
            }.orElse(declOpt)
          }
      }
      val ref = causeOpt.flatMap {cause => SourceRef.get(cause)}.getOrElse {
        mainMessage = "error with unknown location: " + mainMessage
        SourceRef(utils.FileURI(file), SourceRegion(SourcePosition(0,0,0), SourcePosition(0,0,0)))
      }
      holder.createErrorAnnotation(convert(ref.region,psifile),mainMessage)
      ev.addError(mainMessage,extraMessages,file,convert(ref.region,psifile))
    case e: Error =>
      // other errors, should not happen
      val msg =  "error with unknown location: " + e.getMessage
      holder.createErrorAnnotation(TextRange.EMPTY_RANGE,msg)
      ev.addError(msg,e.extraMessage.split("\n").toList,file,TextRange.from(0,0))
  }
}

class ErrorViewer extends ActionListener {
  val aev = new AbstractErrorViewer
  aev.btn_clear.addActionListener(this)
  val root = new PatchedDefaultMutableTreeNode("Errors")
  val errorTree = new Tree(root)
  SwingUtilities.invokeLater { () =>
    aev.pane.setLayout(new BorderLayout())
    val scp = new JScrollPane(errorTree)
    aev.pane.add(scp)
    errorTree.setVisible(true)
    errorTree.setRootVisible(false)
    errorTree.revalidate()
    aev.panel.revalidate()
  }

  implicit def convert[A](e : java.util.Enumeration[A]): List[PatchedDefaultMutableTreeNode] = {
    var ls = Nil.asInstanceOf[List[PatchedDefaultMutableTreeNode]]
    while (e.hasMoreElements) ls ::= e.nextElement().asInstanceOf[PatchedDefaultMutableTreeNode]
    ls.reverse
  }

  def clearFile(file : File) = {
    val entry = root.children().find(_.getUserObject == file).foreach(root.remove)
    SwingUtilities.invokeLater { () =>
      //errorTree.setSize(aev.pane.getSize)
      errorTree.getModel.asInstanceOf[DefaultTreeModel].reload()
      errorTree.revalidate()
    }
  }

  def addError(short : String, long : List[String], file : File, sr : TextRange) = {
    val filetop = root.children().find(_.getUserObject == file).getOrElse {
      val nt = new PatchedDefaultMutableTreeNode(file)
      root.add(nt)
      nt
    }
    val entry = new PatchedDefaultMutableTreeNode(sr.toString + ": " + short)
    long.foreach(s => entry.add(new PatchedDefaultMutableTreeNode(s)))
    filetop.add(entry)
    SwingUtilities.invokeLater { () =>
      //errorTree.setSize(aev.pane.getSize)
      errorTree.getModel.asInstanceOf[DefaultTreeModel].reload()
      errorTree.revalidate()
    }
  }

  override def actionPerformed(e: ActionEvent): Unit = {
    if (e.getActionCommand == "Clear") {
      root.removeAllChildren()
      SwingUtilities.invokeLater { () =>
        errorTree.getModel.asInstanceOf[DefaultTreeModel].reload()
        errorTree.revalidate()
      }
    }
  }
}

class Test extends ToolWindowFactory {
  override def createToolWindowContent(project: Project, toolWindow: ToolWindow): Unit = ???
}